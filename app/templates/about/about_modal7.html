<p>
  Когда нет четко описанной задачи и сроков, хочется, чтобы "творение" радовало глаз. Чем больше смотришь, тем более
  мелкие недостатки выползают на передний план.
</p>
<p>
  Все шаблоны веб-страниц имели много повторяющегося кода, что не просто "нехорошо" и неправильно, но и доставляет
  проблемы, когда что-то нужно подправить. Немного
  <a href="https://jinja.palletsprojects.com/en/2.11.x/">документации</a> и фантазии, и большая часть ненужного кода
  ушла в небытие. Теперь нужные пункты, описание моделей, отображаемые на веб-страницах, можно легко добавлять в
  python-файлах. Переписав большую часть CSS, я изменил дизайн, - появился более приличный адаптив к мобильным
  разрешениям экрана. Добавил раздел <span>About</span>, - никогда не думал, насколько порой сложно вспомнить и описать
  то, что делал несколько дней (месяцев) назад.
</p>
<p>
  Обработка данных (<span>predict</span>) осуществлялась для каждого раздела отдельным своим <span>route</span>,
  практически повторяя одни и те же, за небольшой разницей, действия. Перенес все в одно место в основной
  <span>Blueprint</span> main. Таким образом, в блупринтах разделов остались только роуты, отвечающие за прорисовку
  страниц.
</p>
<p>
  Запуск Lambda-функции осуществлялся из <span>route</span> соответствующего модели раздела, где принимались данные от
  клиента, предварительно обрабатывались, отправлялись в Lambda, после чего обрабатывался ответ Lambda и отсылался
  обратно клиенту, что сопровождалось дополнительными преобразованиями и на текущий момент совсем не нужно. Логичнее
  было бы, чтобы Lambda вызывалась напрямую из клиентского Javascript-а, минуя Flask-часть, что я и реализовал. Имея
  прямую url-ссылку, не составляет особого труда подправить кодировку отправляемых данных и добавить необходимые
  преобразования полученных и отправляемых данных в самой <span>Lambda</span>; пришлось, правда, немного "поколдовать" с
  <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-cors.html">CORS</a>, чтобы подобные
  запросы нормально отрабатывались <span>API Gateway</span>. Для своего рода "обратной совместимости" я добавил
  возможность переключать разные способы вызова <span>Lambda</span> через переменные среды и кофигурацию приложения.
</p>
<p>
  Время обработки изображений, конечно, оставляет желать лучшего. Заметно, что достаточно ощутимый вклад в это время
  оказывает загрузка модели из S3-хранилища и запуск ONNX-сессии. На текущем этапе одна <span>Lambda</span> отрабатывает
  все модели, то есть, не имея своего достаточно большого хранилища, каждый вызов скачивает из S3 файл, который после
  загрузки в ONNX-сессию приходится удалять. И это происходит при каждом вызове функции. Конечно можно сделать несколько
  функций под каждую модель, но хочется сохранить некую универсальность, чтобы, при возможном добавлении новых моделей,
  минимизировать дополнительные действия. Эта тема пока еще в стадии активного обдумывания.
</p>
<p>
  При переключении моделей каждый раз посылается новый запрос с изображением для обработки, даже, если выбрать ту же
  модель, для которой результаты работы модели были получены. Было бы не плохо реализовать какой-нибудь механизм
  кэширования, который бы по запросу возвращал ответ из кеша, если такой точно запрос ранее уже совершался. Для
  кэширования во Flask есть довольно удобное расширение
  <a href="https://flask.palletsprojects.com/en/1.1.x/patterns/caching/">Flask-Caching</a>, которым я и пользовался до
  тех пор, пока не реализовал вызов AWS-Lambda непосредственно из клиентского Javascript-а, - в этом случае запросы
  минуют Flask-приложение, соответственно, ничего кешироваться не будет.
</p>
<p>
  Дальнейшее изучение вопроса привело к использованию веб-интерфейса
  <a href="https://developer.mozilla.org/uk/docs/Web/API/Cache">Cache</a>, и, соответственно
  <a href="https://developers.google.com/web/fundamentals/primers/service-workers">ServiceWorker</a>-ов, являющихся
  основой так называемых "Прогрессивных Веб Приложений" (<a href="https://habr.com/ru/post/418923/">PWA</a>). Как
  оказалось, есть нюансы.
</p>
<p>
  Использование Cache-интерфейса без ServiceWorker-а невозможно. А использование ServiceWorker-а возможно только через
  протокол <span>https</span>. Если, для отладочных целей, запуская приложение локально, можно в браузере внести
  url в список безопасных (как это описано
  <a href="https://stackoverflow.com/questions/52299246/cant-find-serviceworker-in-navigator-anymore">здесь</a>), то для
  продакшена необходима поддержка полноценного
  <a href="https://blog.miguelgrinberg.com/post/running-your-flask-application-over-https">https</a>, причем желательно
  иметь "реальный" сертификат, чтобы не утомлять пользователя лишними предупреждениями.
  <a href="https://devcenter.heroku.com/articles/understanding-ssl-on-heroku">Heroku</a> работает с SSL-сертификатами
  только в платных аккаунтах. <span>Google App Engine</span> же предоставляет обработку https вообще без лишних
  телодвижений, достаточно добавить
  <a href="https://cloud.google.com/appengine/docs/standard/python/config/appref#handlers_secure">пару строк</a> в файл
  конфигурации <span>app.yaml</span>. Таким образом, основная часть приложения была развернута на
  <span>Google App Engine Standart</span>, откуда и загружался <span>Service Worker</span>.
</p>
<p>
  Имеется достаточно большое количество готовых решений на основе <span>Service Worker</span>, одно из них -
  <a href="https://developers.google.com/web/tools/workbox">WorkBox</a> от google, знакомство с которыми я пока оставил
  до лучших времен.
</p>
<p>
  Одно из основных и широко освященных (например
  <a href="https://css-tricks.com/serviceworker-for-offline/">здесь</a>) применений <span>Service Worker</span>-а - в
  кэшировании статических данных, получаемых с помощью GET-запросов. То есть легко можно настроить кэширование css, js и
  прочих статических файлов, что я попутно, пока искал способ кэширования POST-запросов, и сделал. Однако не обошлось
  без сложностей, которые сам себе и создал.
</p>
<p>
  Для удобства, файл сервисворкера <span>sw.js</span> помещен вместе с другими js-файлами в <span>/static/js</span>, а
  из соображений "области видимости" сервисворкера необходимо, чтобы доступ к нему осуществлялся по адресу типа
  <span>https://your-domain.com/sw.js</span>. Для реализации такой "подмены" был создан маршрут:
</p>
<pre>
    @bp.route('/sw.js')
    def sw():
        response = make_response(
            send_from_directory('static/js', filename='sw.js'))
        response.headers['Content-Type'] = 'application/javascript'
        return response</pre
>
<p>
  Проблема возникла, когда я залил в GAE новые версии статических файлов, а также новый <span>sw.js</span>. Google
  закэшировал их на 12 часов. Любой браузер на любом устройстве открывал старые версии файлов из кэша гугла, никакие
  "танцы с бубном" (перезаливка всего кода, очистка хранилищ гугл, добавление
  <a href="https://cloud.google.com/appengine/docs/standard/python3/config/appref#runtime_and_app_elements"
    >default_expiration</a
  >
  в файл <span>app.yaml</span>) не приводили ни к чему, только переименование всех статических файлов решало проблему,
  что меня не устраивало. Проблема оказалась в следующем.
</p>
<p>
  Как написано
  <a href="https://cloud.google.com/appengine/docs/standard/python3/config/appref#static_cache_expiration">здесь</a> и,
  что более важно,
  <a
    href="https://cloud.google.com/appengine/docs/standard/python3/reference/request-response-headers#headers_added_or_replaced"
    >здесь</a
  >, гугл всегда кэширует статические файлы. Но правила, согласно которым он кэширует, берутся либо из
  <span>header</span>-ов ответов приложения либо, при их отсутствии, согласно <span>default_expiration</span>. В моем
  случае Flask выдавал с ответами такие заголовки, где, согласно
  <a href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.Flask.send_file_max_age_default">этому</a>, время жизни
  кэша назначалось как раз 12 часов. Несколько часов поисков, затем несколько часов ожидания истечения 12-ти часов, и
  <span>SEND_FILE_MAX_AGE_DEFAULT=300</span> в конфигурации приложения решили проблему.
</p>
<p>
  Немного модифицировав код из
  <a href="https://a.kabachnik.info/offline-post-requests-via-service-worker-and-indexeddb.html">этой статьи</a>, была
  реализована возможность кэширования POST-запросов. Было решено не кэшировать весь запрос, как в источнике, а только
  его <a href="https://snipp.ru/jquery/md5-js">MD5 hash</a>. Для хранения кэшированных запросов, как и в статье,
  использовалась
  <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB">IndexedDB</a
  >, которая работает во всех современных браузерах, а также удобная "обертка" для нее -
  <a href="https://dexie.org/">Dexie</a>.
</p>
<p>
    Весь код приложения можно посмотреть в <a href="https://github.com/tuuka/cv-demo">репозитории</a>.
</p>
